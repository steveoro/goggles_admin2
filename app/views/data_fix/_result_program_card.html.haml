-# frozen_string_literal: true

:ruby
  # Displays a collapsible card for a MeetingProgram group with expandable result rows
  #
  # == Params:
  # - program_key: String, e.g., "1-200RA-M75-F"
  # - results: Array of DataImportMeetingIndividualResult
  # - swimmers_by_id: Hash of Swimmer by ID
  # - teams_by_id: Hash of Team by ID (for matched teams)
  # - teams_by_key: Hash of Team data by key (for unmatched teams from phase 2)
  # - team_key_by_swimmer_key: Hash mapping swimmer_key => team_key (from phase 3 badges)
  # - laps_by_parent_key: Hash of DataImportLap arrays by parent_import_key
  # - card_index: Integer, for unique IDs
  parts = program_key.split('-')
  session_order = parts[0]
  event_code = parts[1]
  category = parts[2]
  gender = parts[3]
  # Split results: non-DSQ first (sorted by rank), then DSQ (natural order)
  non_dsq_results = results.reject(&:disqualified?).sort_by(&:rank)
  dsq_results = results.select(&:disqualified?)
  sorted_results = non_dsq_results + dsq_results
  program_id = results.first&.meeting_program_id
  has_match = program_id.present?
  border_color = has_match ? 'border-success' : 'border-warning'
  border_width = 'border-2'
  
  # Check if any result has missing swimmer data
  has_issues = sorted_results.any? do |mir|
    if mir.swimmer_id
      swimmer = swimmers_by_id[mir.swimmer_id]
      swimmer && (swimmer.gender_type_id.nil? || swimmer.year_of_birth.nil?)
    else
      mir.swimmer_key && swimmer_has_missing_data?(mir.swimmer_key, swimmers_by_key: swimmers_by_key).values.any?
    end
  end

.card.mb-2{ class: "#{border_color} #{border_width}", id: "program-card-#{card_index}", data: { has_issues: has_issues } }
  .card-header.d-flex.justify-content-between.align-items-center{ id: "program-header-#{card_index}", style: 'cursor: pointer;', data: { toggle: 'collapse', target: "#program-panel-#{card_index}" } }
    .d-flex.align-items-center
      %span.mr-2
        - if has_match
          %i.fa.fa-check-circle.text-success{ title: 'Matched MeetingProgram' }
        - else
          %i.fa.fa-plus-circle.text-warning{ title: 'New MeetingProgram' }
      %strong
        = "#{event_code} • #{category} • #{gender}"
      &nbsp;
      %small.ml-2.text-muted
        Session #{session_order}
      - if has_match
        %small.ml-2.badge.badge-success
          ID: #{program_id}
      - else
        %small.ml-2.badge.badge-primary
          NEW
    .d-flex.align-items-center
      %span.badge.badge-info
        = "#{sorted_results.size} results"

  .collapse.show{ id: "program-panel-#{card_index}", 'aria-labelledby' => "program-header-#{card_index}" }
    .card-body.p-0
      %table.table.table-sm.table-hover.mb-0
        %thead.thead-light
          %tr
            %th.text-center{ style: 'width: 40px;' }
            %th.text-center{ style: 'width: 50px;' } Rank
            %th Swimmer
            %th Team
            %th.text-right Timing
            %th.text-center Status
        %tbody
          - sorted_results.each_with_index do |mir, idx|
            :ruby
              swimmer = swimmers_by_id[mir.swimmer_id]
              # Try to find team by ID first (matched teams)
              team = teams_by_id[mir.team_id]
              team_data = nil
              # If no team found by ID, look up by key using swimmer_key from import_key
              if team.nil? && teams_by_key.present? && team_key_by_swimmer_key.present?
                swimmer_key = mir.import_key.split('/')[1] # Extract swimmer_key from import_key
                team_key = team_key_by_swimmer_key[swimmer_key]
                team_data = teams_by_key[team_key] if team_key
              end
              # Fully matched = swimmer AND team both have DB IDs
              is_fully_matched = swimmer.present? && team.present?
              laps = laps_by_parent_key[mir.import_key] || []
              has_laps = laps.any?
              result_id = "result-#{card_index}-#{idx}"
            %tr{ id: "#{result_id}-row" }
              %td.text-center
                - if has_laps
                  %i.fa.fa-chevron-right{ style: 'cursor: pointer;', data: { toggle: 'collapse', target: "##{result_id}-laps" }, onclick: 'this.classList.toggle("fa-chevron-right"); this.classList.toggle("fa-chevron-down");' }
              %td.text-center
                - if mir.disqualified?
                  %span.text-muted -
                - else
                  = mir.rank
              %td
                - if swimmer
                  = swimmer.complete_name
                  %small.text-muted= "(#{swimmer.year_of_birth})"
                - else
                  %code.text-muted= mir.import_key.split('/')[1]
              %td
                - if team
                  = team.editable_name
                - elsif team_data
                  = team_data['editable_name'] || team_data['name']
                - else
                  %span.text-muted N/A
              %td.text-right
                - if mir.disqualified?
                  %span.text-muted —
                - else
                  %strong= mir.to_timing.to_s
              %td.text-center
                - if mir.disqualified?
                  %span.badge.badge-danger DSQ
                - elsif is_fully_matched
                  %i.fa.fa-check-circle.text-success{ title: 'Swimmer & Team fully matched to DB' }
                - else
                  %i.fa.fa-plus-circle.text-warning{ title: 'New or unmatched (swimmer or team)' }
            - if has_laps
              %tr.collapse{ id: "#{result_id}-laps" }
                %td{ colspan: 6 }
                  .bg-light.p-2
                    %table.table.table-sm.mb-0
                      %thead
                        %tr
                          %th.text-center Distance
                          %th.text-right Delta
                          %th.text-right From Start
                      %tbody
                        - laps.each do |lap|
                          :ruby
                            # Delta timing (default columns)
                            delta_timing = Timing.new(
                              minutes: lap.minutes,
                              seconds: lap.seconds,
                              hundredths: lap.hundredths
                            )
                            # From-start timing (cumulative)
                            from_start_timing = Timing.new(
                              minutes: lap.minutes_from_start,
                              seconds: lap.seconds_from_start,
                              hundredths: lap.hundredths_from_start
                            )
                          %tr
                            %td.text-center
                              %strong= "#{lap.length_in_meters}m"
                            %td.text-right
                              = delta_timing.to_s
                            %td.text-right.text-muted
                              = from_start_timing.to_s
