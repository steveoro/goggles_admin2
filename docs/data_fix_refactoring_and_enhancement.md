# DataFix refactoring and enhancement

- 20251006: note that this document was based on what is now called DataFixLegacyController (previously "DataFixController", now replaced by its version 2)

- This was the starting document for the refactoring of the data fix process, which was split into multiple phases. See: docs/data_fix_refactoring_and_enhancement.md

---

## Current situation:

- DataFixController handles the manual review of the parsed JSON data file.

- The JSON data file is usually created by the legacy crawler, or can be generated by the PDF parsing process. Both generate a Hash using the "layoutType" 2 structure which gets serialized to a JSON file.

- The JSON object is expected to be a Hash using the "layoutType" 2 structure. (For details, see a sample JSON file in crawler/data/results.done/ or crawler/data/results.new/)

- The main objective of the manual review is to check if any of the data stored in data hash to be processed have or not a corresponding set of rows on the database.

- For each entity type, the JSON data file contains a set of fields that need to be "solved" in order to find the best matching rows in the DB, as not all information may be available to pinpoint an exact match. For example, a Swimmer may be identified by its name, gender, birthdate and team, but not all the times these fields may be available or, even, have a constant value (the name may be shortened, there could be typos, etc).

- So, for each possible entity in the database, the "data fix" process aims at finding the best matching rows in the DB for all sections (meeting, meeting session, team, swimmer, etc), and, if not found, creating new rows or updating existing ones.

- The phases of the "data fix" process are:
  1) Review meeting, with place(s) (venues/pools) and sessions (a meeting may be divided into several days or sessions, with multiple pools involved)
  2) Review teams
  3) Review swimmers
  4) Review events
  5) Review results

- Currently, only phases 1..4 allow to add manually new rows to the data hash. Phase #5 is considered a read-only phase that allows a global overview of the results data to be processed.

- Each phase in the controller is handled by a specific action, which is responsible for loading the data hash, "solving" the entities (i.e. finding the best matching rows in the DB), and then serializing the data hash back to the JSON file.

- The "solving" process is handled by the MacroSolver class, which is responsible for finding the best matching rows in the DB for each entity type.

- There's a single `PATCH /data_fix/update` action that allegedly handles any type of entity editing made in the review phases, depending on the model name and parameters specified in the request. As this is a convoluted unmaintainable mess, we should refactor it if possible, or split it in multiple, dedicated actions.


## Main goals of the refactoring:

1. Support other layout types. As top priority, we should support both JSON results layoutType 2 and 4. Layout types 1 and 3 can be ignored as they are usually converted to layoutType 2 by a dedicated strategy class.

2. Keep the number of existing review phases as they are, but make them more generic and flexible, so that they can be used for any layout type.

3. Refactor any existing code using dedicated strategy or service classes that could be tested in isolation.


## Possible approaches:

1. Handle any other layoutType as the JSON layoutType 2, by using a dedicated strategy class that converts the data hash to the expected structure. This way we could reuse the same controller actions as before with minimal changes.

2. Consider creating a new controller for each layoutType, with its own actions and logic. We could reuse most of the views and components, but we'll need new implementations.


## About the "layoutType 2" result structure and how it's being used:

Typical layoutType 2 structure before the start of the data-fix process:

```json
  {
    "layoutType": 2,
    "name": "DESCRIPTIVE_MEETING_NAME", // (Can include the year or an ordinal number for the meeting)
    "meetingURL": "MEETING_RESULTS_URL",
    "manifestURL": "MEETING_MANIFEST_URL",
    "dateDay1": "10",        // Day of the month (starting date of the event)
    "dateMonth1": "Marzo",   // Month name in Italian (starting date of the event)
    "dateYear1": "2024",     // Year (starting date of the event)
    "dateDay2": null,        // Day of the month (ending date of the event)
    "dateMonth2": null,      // Month name in Italian (ending date of the event)
    "dateYear2": null,       // Year (ending date of the event)
    "organization": "ORGANIZATION_NAME", // Name of the team or organization for the meeting
    "venue1": "VENUE_1_NAME",
    "address1": "VENUE_1_ADDRESS",
    "venue2": "VENUE_2_NAME",
    "address2": "VENUE_2_ADDRESS",
    "poolLength": "POOL_LENGTH", // In meters; same pool length for all venues
    "registration": "REGISTRATION_PERIOD",
    "resultsPdfURL": "URL_OF_RESULTS_DOWNLOAD",
    "sections": [
        // 1 section per "event tuple" (event, category, gender):
        {
            "title": "DESCRIPTIVE_EVENT_NAME_IN_ITA", // Example: "100 Stile Libero - M20"
            "fin_id_evento": "FIN_EVENT_ID", // Example: "143816"
            "fin_codice_gara": "FIN_EVENT_CODE", // Example: "00"
            "fin_sigla_categoria": "CATEGORY_CODE", // Example: "M25"
            "fin_sesso": "GENDER_CODE", // Example: "M"
            "rows": [
                // Example of a single individual result row:
                {
                    "pos": "RANKING_POSITION", // Example: "1"
                    "name": "LAST_NAME FIRST_NAME", // Example: "ROSSI MARCO"
                    "year": "YEAR_OF_BIRTH", // Example: "1990"
                    "sex": "GENDER_CODE", // Example: "M"
                    "team": "TEAM_NAME", // Example: "Super Swim Team"
                    "timing": "FINISHING_TIME", // Example: "27.33"
                    "score": "SCORE" // Example: "793,27"
                },
                // (...more rows for the same event...)
            ]
        }
    ]
  }
```

The `season_id` value is extracted from file path, because the result file being processed is assumed to be stored already in a folder containing the `season_id` in its path (like "crawler/data/results.new/242/<meeting_iso_date>-<meeting_name>.json").

During the 'data-fix' process, entities are matched with the data, sometimes hand-picked, and appended to the resulting JSON file as additional key sections, following the "sections" key array, and named accordingly in the following order:

1. 'meeting'
2. 'city'
3. 'swimming_pool' (links with `city_id`)
4. 'meeting_session' (links with `swimming_pool_id`)
5. 'team' (may include references to `city_id`)
6. 'swimmer'
7. 'badge' (links both `team_id` and `swimmer_id`)
8. 'meeting_event' (links with `meeting_session_id`)
9. 'meeting_program' (links with `meeting_event_id`)
10. 'meeting_individual_result' (links with `meeting_program_id`, `swimmer_id`, `team_id` and `badge_id`)
11. 'meeting_relay_result' (added only when relay results are found in the processed file; links with `meeting_program_id`, `team_id` and `badge_id`)
12. 'lap' (added only when lap timings are found in the processed file; links with `meeting_individual_result_id`)
13. 'relay_lap' (added only when relay results with laps are found in the processed file; links with `meeting_relay_result_id`)
14. 'meeting_relay_swimmer' (added only when relay results with laps and swimmers are found in the processed file; links with `meeting_relay_result_id` and `swimmer_id`)
15. 'meeting_team_score' (added only when final team ranking scores are found in the processed file; links with `team_id`)

Each added section acts as a look-up reference table or "dictionary" for the data-fix process, containing the attribute values from the actual database rows that have been found or selected by the user as a valid match for the corresponding data in the JSON file being processed.

The structure for each added section is the same and has the structure `<absolute_string_key> => { "row" => <hash_of_attributes>, "matches" => <array_of_possible_matches> }`

Where:
- `absolute_string_key` is a unique key generated from the absolute values of the "key attributes" of the entity in the JSON file being processed; some examples:
  - `team` => `team_name_as_found_on_the_file` (may be edited by the user afterwards, so the key must never change)
  - `swimmer` => `first_name_as_found` +`-`+ `last_name_as_found` +`-`+ `year_of_birth` +`-`+ `gender` +`-`+ `team_name_as_found_on_the_file`
  - `badge` => `same_key_as_swimmer` (it contains every key attribute of the swimmer, and each swimmer may have only 1 badge)
  Notable exceptions are `meeting` and `meeting_session`, which are added as simple object to the dictionary, without any key attributes, because the meeting is already unique per each file and the meeting sessions is just an array of "session objects" all automatically linked to the same meeting.

- `row` is the actual database row that has been found or selected by the user as a valid match for the corresponding data in the JSON file being processed, stored as a hash of attributes.
- `matches` is an array of possible matches found in the database for the corresponding data in the JSON file being processed, stored as an array of attribute hashes, similar to the "row" object.

The goal of having all these "dictionary" sections is to provide a simple way at the end of the data-fix to commit all data and finalize the acquisition into the database by simply scanning all "row" objects gathered (or generated) during the data-fix process.

At the final commit stage, the `MacroCommitter` class will re-read the whole processed JSON file, create an in-memory equivalent and, for each added section, recreate the corresponding database row, by either creating it if missing or updating it with the data attributes in the current "row" object.

After a successful commit, the JSON file is moved from its original location to a "processed" folder, so that it can be easily retrieved later if needed.


## Supporting classes:

These can all be found under `app/strategies/import/`:

- `Import::Entity`: wrapper for actual DB Models built or retrieved by the Import::MacroSolver.

- `Import::MacroSolver`: main "matcher" class, allows to parse into actual database values most of the text labels and names found in the JSON file being processed; handles the creation of new entities and the matching of existing ones.

- `Import::MacroCommitter`: handles the final commit of the processed JSON file, creating or updating the database rows based on the "row" objects gathered (or generated) during the data-fix process.
